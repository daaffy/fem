"""
STOCHASTIC DOMAIN MODEL
to do:
- PEERS element (necessary?)
"""

from __future__ import print_function
from fenics import *
from mshr import *
import matplotlib.pyplot as plt
import numpy, h5py
from multiphenics import *
parameters["ghost_mode"] = "shared_facet" # required by dS

# import eval_points as generated by MATLAB script
f = h5py.File('eval_points.h5','r')
eval_points = numpy.transpose(numpy.array(f['data']))

# ---------------------------------------------------------------------
# MESH, SUBDOMAINS AND RESTRICTIONS

# domain IDs
solid_dom = 1
fluid_dom = 2

# Create mesh
eps = -0.0
a = 1.0 + eps # should be equal to 1.0
b = 2.0 + eps
domain = Rectangle(Point(-b,-b),Point(b,b))
# domain_inside = Rectangle(Point(-a, -a), Point(a, a))
# domain.set_subdomain(solid_dom, domain)
# domain.set_subdomain(fluid_dom, domain_inside)
mesh = generate_mesh(domain, 20)

# Create boundaries
class OnBoundary(SubDomain):
    def inside(self, x, on_boundary):
        return on_boundary
# class OnInterface(SubDomain):
#     def inside(self, x, on_boundary):
#         return (near(x[0], -a) or near(x[0], a)) and between(x[1], [-a, a]) or (near(x[1], -a) or near(x[1], a)) and between(x[0], [-a, a])

boundaries = MeshFunction("size_t", mesh, mesh.topology().dim() - 1)
on_boundary = OnBoundary()
on_boundary.mark(boundaries, 1)
# on_interface = OnInterface()
# on_interface.mark(boundaries, 2)


# Create restrictions
nudge = 0.01 # look into getting rid of this...
# class Fluid(SubDomain):
#     def inside(self, x, on_boundary):
#         return between(x[0],[-a,a]) and between(x[1],[-a,a])
class Solid(SubDomain):
    def inside(self, x, on_boundary):
        return True
        # return not(between(x[0],[-a+nudge,a-nudge]) and between(x[1],[-a+nudge,a-nudge]))

# Create subdomains
subdomains = MeshFunction("size_t", mesh, mesh.topology().dim(), mesh.domains()) # 4th argument passes the domain tags to the mesh function
solid = Solid()
# fluid = Fluid()

# boundary_restriction = MeshRestriction(mesh, on_boundary)
# interface_restriction = MeshRestriction(mesh, on_interface)
# fluid_restriction = MeshRestriction(mesh, fluid)
solid_restriction = MeshRestriction(mesh, solid)

# plt.figure()
# p = plot(mesh)
# plt.show()

# ---------------------------------------------------------------------
# DEFINE FUNCTION SPACES

_B = FunctionSpace(mesh, "Bubble", 3)
_H = FunctionSpace(mesh, 'RT', 1) 
# P1 = FunctionSpace(mesh, "RT", 2) # (!) Use FiniteElement??? See UFL doc sheet
# P2 = FunctionSpace(mesh, "CG", 1)
R = FunctionSpace(mesh, "CG", 1)
# P3 = VectorFunctionSpace(mesh, "CG", 2)
V = BlockFunctionSpace([_H, _B, _H, _B, R], restrict=[solid_restriction, solid_restriction, solid_restriction, solid_restriction, solid_restriction])
          
# sigma = as_tensor((a1,a2))+as_tensor([[b[0].dx(1),-b[0].dx(0)],[b[1].dx(1),-b[1].dx(0)]])  #in 2D
# ---------------------------------------------------------------------
# BUILD LINEAR FORMS

# parameters
rho_s = 1
rho_f = 1
omega = sqrt(2)*Constant(pi)
lamb = 1
nu = 1
c = omega/(sqrt(2)*Constant(pi))
C = numpy.array([[2*nu+lamb, 0, 0, lamb], [0, 2*nu, 0, 0], [0, 0, 2*nu, 0], [lamb, 0, 0, 2*nu+lamb]])
invC = numpy.linalg.inv(C)
invC_11 = as_matrix(invC[0:2,0:2]) # for d2 bilinear form
invC_12 = as_matrix(invC[0:2,2:4])
invC_21 = as_matrix(invC[2:4,0:2])
invC_22 = as_matrix(invC[2:4,2:4])

# Define variational problem
trial_func = BlockTrialFunction(V) # trial = "solution", test = "function to test against"
(sig1_H, pre_sig1_B, sig2_H, pre_sig2_B, r) = block_split(trial_func)

test_func = BlockTestFunction(V)
(tau1_H, pre_tau1_B, tau2_H, pre_tau2_B, s) = block_split(test_func)

sig1_B = as_vector([pre_sig1_B.dx(1),-pre_sig1_B.dx(0)])
sig2_B = as_vector([pre_sig2_B.dx(1),-pre_sig2_B.dx(0)])
tau1_B = as_vector([pre_tau1_B.dx(1),-pre_tau1_B.dx(0)])
tau2_B = as_vector([pre_tau2_B.dx(1),-pre_tau2_B.dx(0)])

stress_a = Expression((('pi*sin(pi*(x[0]+x[1]))+2*pi*cos(pi*x[0])*sin(pi*x[1])','pi*sin(pi*(x[0]+x[1]))'),
                    ('pi*sin(pi*(x[0]+x[1]))','pi*sin(pi*(x[0]+x[1]))+2*pi*sin(pi*x[0])*cos(pi*x[1])')), degree=2)
pressure_a = Expression('cos(pi*x[0])*cos(pi*x[1])', degree=2)

f = Constant((0.0,1.0))
#f = [Expression('2*pi*pi*cos(pi*(x[0]+x[1]))', degree=2), Expression('2*pi*pi*cos(pi*(x[0]+x[1]))', degree=2)]
n = FacetNormal(mesh)
# g = stress_a*n + pressure_a*n
g = Constant((0.0,0.0))

temp_sgn_1 = '+' #sig etc.
temp_sgn_n = '+'
temp_sgn_pr = '+'
temp_sgn_2 = '+' #psi/phi

# MEASURES #
dx = Measure("dx")(subdomain_data=subdomains)
ds = Measure("ds")(subdomain_data=boundaries)
# dS = Measure("dS")(subdomain_data=boundaries)
# dS = dS(2) # restrict to the interface, which has facet ID equal to 2

def s11(sig_vec,tau_vec,invC_):
    return div(sig_vec)*div(tau_vec)/rho_s*dx(solid_dom) -omega**2*dot(invC_*sig_vec,tau_vec)*dx(solid_dom)

def s12(sig_vec,tau_vec,invC_):
    return -omega**2*dot(invC_*sig_vec,tau_vec)*dx(solid_dom)

def r1(sig_vec,s,i):
    return s*sig_vec[i]*dx(solid_dom)

# a = [[s11(sig1_H,tau1_H,invC_11), s11(sig1_B,tau1_H,invC_11), s12(sig2_H,tau1_H,invC_12), s12(sig2_B,tau1_H,invC_12), -r*tau1_H[1]*dx(solid_dom), 0, -omega**2*dot(as_vector([dot(tau1_H(temp_sgn_1),n(temp_sgn_n)),0]),phi(temp_sgn_2))*dS],
#      [s11(sig1_H,tau1_B,invC_11), s11(sig1_B,tau1_B,invC_11), s12(sig2_H,tau1_B,invC_12), s12(sig2_B,tau1_B,invC_12), -r*tau1_B[1]*dx(solid_dom), 0, -omega**2*dot(as_vector([dot(tau1_B(temp_sgn_1),n(temp_sgn_n)),0]),phi(temp_sgn_2))*dS],
#      [s12(sig1_H,tau2_H,invC_21), s12(sig1_B,tau2_H,invC_21), s11(sig2_H,tau2_H,invC_22), s11(sig2_B,tau2_H,invC_22), r*tau2_H[0]*dx(solid_dom), 0, -omega**2*dot(as_vector([0,dot(tau2_H(temp_sgn_1),n(temp_sgn_n))]),phi(temp_sgn_2))*dS],
#      [s12(sig1_H,tau2_B,invC_21), s12(sig1_B,tau2_B,invC_21), s11(sig2_H,tau2_B,invC_22), s11(sig2_B,tau2_B,invC_22), r*tau2_B[0]*dx(solid_dom), 0, -omega**2*dot(as_vector([0,dot(tau2_B(temp_sgn_1),n(temp_sgn_n))]),phi(temp_sgn_2))*dS],
#      [-omega**2*s*sig1_H[1]*dx(solid_dom), -omega**2*s*sig1_H[1]*dx(solid_dom), omega**2*s*sig2_H[0]*dx(solid_dom), omega**2*s*sig2_B[0]*dx(solid_dom), 0, 0, 0],
#      [0, 0, 0, (dot(grad(p), grad(q)) - (omega**2/(c**2*rho_f))*p*q)*dx(fluid_dom), -omega**2*dot(q(temp_sgn_pr)*n(temp_sgn_n),phi(temp_sgn_2))*dS],
#      [-omega**2*dot(as_vector([dot(sig1_H(temp_sgn_1),n(temp_sgn_n)),0]),psi(temp_sgn_2))*dS, -omega**2*dot(as_vector([dot(sig1_B(temp_sgn_1),n(temp_sgn_n)),0]),psi(temp_sgn_2))*dS, -omega**2*dot(as_vector([0,dot(sig2_H(temp_sgn_1),n(temp_sgn_n))]),psi(temp_sgn_2))*dS, 0, -omega**2*dot(p(temp_sgn_pr)*n(temp_sgn_n),psi(temp_sgn_2))*dS, -omega**2*dot(as_vector([0,dot(sig2_B(temp_sgn_1),n(temp_sgn_n))]),psi(temp_sgn_2))*dS, 0, -omega**2*dot(p(temp_sgn_pr)*n(temp_sgn_n),psi(temp_sgn_2))*dS, 0]]

a = [[s11(sig1_H,tau1_H,invC_11), s11(sig1_B,tau1_H,invC_11), s12(sig2_H,tau1_H,invC_12), s12(sig2_B,tau1_H,invC_12), -r1(tau1_H,r,1)],
     [s11(sig1_H,tau1_B,invC_11), s11(sig1_B,tau1_B,invC_11), s12(sig2_H,tau1_B,invC_12), s12(sig2_B,tau1_B,invC_12), -r1(tau1_B,r,1)],
     [s12(sig1_H,tau2_H,invC_21), s12(sig1_B,tau2_H,invC_21), s11(sig2_H,tau2_H,invC_22), s11(sig2_B,tau2_H,invC_22), r1(tau2_H,r,0)],
     [s12(sig1_H,tau2_B,invC_21), s12(sig1_B,tau2_B,invC_21), s11(sig2_H,tau2_B,invC_22), s11(sig2_B,tau2_B,invC_22), r1(tau1_B,r,0)],
     [-omega**2*r1(sig1_H,s,1), -omega**2*r1(sig1_B,s,1), omega**2*r1(sig2_H,s,0), omega**2*r1(sig2_B,s,0), 0]]

# l =  [f[0]*div(tau1_H)*dx(solid_dom), f[0]*div(tau1_B)*dx(solid_dom), f[1]*div(tau2_H)*dx(solid_dom), f[1]*div(tau2_B)*dx(solid_dom), 0, 0, -omega**2*dot(g('+'),psi('+'))*dS]
l =  [f[0]*div(tau1_H)*dx(solid_dom), f[0]*div(tau1_B)*dx(solid_dom), f[1]*div(tau2_H)*dx(solid_dom), f[1]*div(tau2_B)*dx(solid_dom), 0]

A = block_assemble(a)
L = block_assemble(l)

# print(sum(sum(A.array())))

# ---------------------------------------------------------------------
# Compute solution
U = BlockFunction(V) # initialize solution function object
block_solve(A, U.block_vector(), L) # solve linear variational problem

# ---------------------------------------------------------------------
# PLOT SOLUTION
plt.figure()
p = plot(U[3]) # (sig1_H, pre_sig1_B, sig2_H, pre_sig2_B, r)
plt.show()

# ---------------------------------------------------------------------
# evaluate at eval_points and export
stress_python = numpy.zeros([numpy.size(eval_points,1), 4])
pressure_python = numpy.zeros([numpy.size(eval_points,1), 1])

# bbt = mesh.bounding_box_tree()
# x = Point(2.5,0)
# print(bbt.compute_first_entity_collision(x))

for i in range(numpy.size(eval_points,1)):
  x = Point(eval_points[0,i],eval_points[1,i])
  stress_python[i,:] = numpy.append(U[0](x), U[2](x))
  # pressure_python[i] = U[3](x)
  # print(stress_python[i,:])

print(stress_python)
# # export
# # note: need to transpose pressure vec for matlab to read properly
# stress_python = numpy.transpose(stress_python) # i think h5py reads opposite to the way h5(matlab) writes, and vice versa 
# W = h5py.File('./stress_python.h5','w')
# W.create_dataset(name='data', data=stress_python, dtype='f4') # to current directory
# W = h5py.File('./pressure_python.h5','w')
# W.create_dataset(name='data', data=pressure_python, dtype='f4') # to current directory

# W = h5py.File('../Thanh Research/FEM local/src_copy/stress_python.h5','w')
# W.create_dataset(name='data', data=stress_python, dtype='f4') # to matlab directory
# W = h5py.File('../Thanh Research/FEM local/src_copy/pressure_python.h5','w')
# W.create_dataset(name='data', data=pressure_python, dtype='f4') # to matlab directory
