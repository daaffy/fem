"""
STOCHASTIC DOMAIN MODEL
to do:
- PEERS element (necessary?)
"""

from __future__ import print_function
from fenics import *
from mshr import *
import matplotlib.pyplot as plt
import numpy, h5py
import random
from multiphenics import *
parameters["ghost_mode"] = "shared_facet" # required by dS

# import eval_points as generated by MATLAB script
# f = h5py.File('eval_points.h5','r')
# eval_points = numpy.transpose(numpy.array(f['data']))

# ---------------------------------------------------------------------
# MESH, SUBDOMAINS AND RESTRICTIONS

# domain IDs
solid_dom = 1
fluid_dom = 2

# Create mesh
eps = -0.0
a = 1.0 + eps # should be equal to 1.0
b = 2.0 + eps
domain = Rectangle(Point(-b,-b),Point(b,b))
domain_inside = Rectangle(Point(-a, -a), Point(a, a))
domain.set_subdomain(solid_dom, domain)
domain.set_subdomain(fluid_dom, domain_inside)
mesh = generate_mesh(domain, 110)

# Create boundaries
class OnBoundary(SubDomain):
    def inside(self, x, on_boundary):
        return on_boundary
class OnInterface(SubDomain):
    def inside(self, x, on_boundary):
        return (near(x[0], -a) or near(x[0], a)) and between(x[1], [-a, a]) or (near(x[1], -a) or near(x[1], a)) and between(x[0], [-a, a])

boundaries = MeshFunction("size_t", mesh, mesh.topology().dim() - 1)
on_boundary = OnBoundary()
on_boundary.mark(boundaries, 1)
on_interface = OnInterface()
on_interface.mark(boundaries, 2)


# Create restrictions
nudge = 2*DOLFIN_EPS # look into getting rid of this...
class Fluid(SubDomain):
    def inside(self, x, on_boundary):
        return between(x[0],[-a,a]) and between(x[1],[-a,a])
class Solid(SubDomain):
    def inside(self, x, on_boundary):
        return not(between(x[0],[-a+nudge,a-nudge]) and between(x[1],[-a+nudge,a-nudge]))

# Create subdomains
subdomains = MeshFunction("size_t", mesh, mesh.topology().dim(), mesh.domains()) # 4th argument passes the domain tags to the mesh function
solid = Solid()
fluid = Fluid()

boundary_restriction = MeshRestriction(mesh, on_boundary)
interface_restriction = MeshRestriction(mesh, on_interface)
fluid_restriction = MeshRestriction(mesh, fluid)
solid_restriction = MeshRestriction(mesh, solid)

# plt.figure()
# p = plot(mesh)
# plt.show()

# ---------------------------------------------------------------------
# DEFINE FUNCTION SPACES

P1 = FunctionSpace(mesh, "RT", 2) # (!) Use FiniteElement??? See UFL doc sheet
P2 = FunctionSpace(mesh, "CG", 1)
R = FunctionSpace(mesh, "CG", 1)
P3 = VectorFunctionSpace(mesh, "CG", 2)
V = BlockFunctionSpace([P1, P1, R, P2, P3], restrict=[solid_restriction, solid_restriction, solid_restriction, fluid_restriction, interface_restriction])


# ---------------------------------------------------------------------
# BUILD LINEAR FORMS

# parameters
rho_s = 1
rho_f = 1
omega = sqrt(2)*Constant(pi)
lamb = 1
nu = 1
c = omega/(sqrt(2)*Constant(pi))
C = numpy.array([[2*nu+lamb, 0, 0, lamb], [0, 2*nu, 0, 0], [0, 0, 2*nu, 0], [lamb, 0, 0, 2*nu+lamb]])
invC = numpy.linalg.inv(C)
invC_11 = as_matrix(invC[0:2,0:2]) # for d2 bilinear form
invC_12 = as_matrix(invC[0:2,2:4])
invC_21 = as_matrix(invC[2:4,0:2])
invC_22 = as_matrix(invC[2:4,2:4])

# Define variational problem
trial_func = BlockTrialFunction(V) # trial = "solution", test = "function to test against"
(sig1, sig2, r, p, phi) = block_split(trial_func)

test_func = BlockTestFunction(V)
(tau1, tau2, s, q, psi) = block_split(test_func)

stress_a = Expression((('pi*sin(pi*(x[0]+x[1]))+2*pi*cos(pi*x[0])*sin(pi*x[1])','pi*sin(pi*(x[0]+x[1]))'),
                    ('pi*sin(pi*(x[0]+x[1]))','pi*sin(pi*(x[0]+x[1]))+2*pi*sin(pi*x[0])*cos(pi*x[1])')), degree=3)
pressure_a = Expression('cos(pi*x[0])*cos(pi*x[1])', degree=3)

# f = Constant((0.0,1.0))
f = [Expression('2*pi*pi*cos(pi*(x[0]+x[1]))', degree=2), Expression('2*pi*pi*cos(pi*(x[0]+x[1]))', degree=3)]
n = FacetNormal(mesh)
g = stress_a*n + pressure_a*n
# g = Constant((0.0,0.0))

temp_sgn_1 = '+' #sig etc.
temp_sgn_n = '+'
temp_sgn_pr = '+'
temp_sgn_2 = '+' #psi/phi

# MEASURES #
dx = Measure("dx")(subdomain_data=subdomains)
ds = Measure("ds")(subdomain_data=boundaries)
dS = Measure("dS")(subdomain_data=boundaries)
dS = dS(2) # restrict to the interface, which has facet ID equal to 2

a = [[div(sig1)*div(tau1)/rho_s*dx(solid_dom) - omega**2*dot(invC_11*sig1,tau1)*dx(solid_dom), - omega**2*dot(invC_12*sig2,tau1)*dx(solid_dom),   -r*tau1[1]*dx(solid_dom) , 0, -omega**2*dot(as_vector([dot(tau1(temp_sgn_1),n(temp_sgn_n)),0]),phi(temp_sgn_2))*dS],
     [- omega**2*dot(invC_21*sig1,tau2)*dx(solid_dom), div(sig2)*div(tau2)/rho_s*dx(solid_dom) - omega**2*dot(invC_22*sig2,tau2)*dx(solid_dom), r*tau2[0]*dx(solid_dom) , 0, -omega**2*dot(as_vector([0,dot(tau2(temp_sgn_1),n(temp_sgn_n))]),phi(temp_sgn_2))*dS],
     [-omega**2*s*sig1[1]*dx(solid_dom)             , omega**2*s*sig2[0]*dx(solid_dom)       , 0            , 0       , 0],
     [0, 0, 0, (dot(grad(p), grad(q)) - (omega**2/(c**2*rho_f))*p*q)*dx(fluid_dom), -omega**2*dot(q(temp_sgn_pr)*n(temp_sgn_n),phi(temp_sgn_2))*dS],
     [-omega**2*dot(as_vector([dot(sig1(temp_sgn_1),n(temp_sgn_n)),0]),psi(temp_sgn_2))*dS, -omega**2*dot(as_vector([0,dot(sig2(temp_sgn_1),n(temp_sgn_n))]),psi(temp_sgn_2))*dS, 0, -omega**2*dot(p(temp_sgn_pr)*n(temp_sgn_n),psi(temp_sgn_2))*dS, 0]]

l =  [f[0]*div(tau1)*dx(solid_dom)                       , f[1]*div(tau2)*dx(solid_dom)                       , 0 , 0, -omega**2*dot(g('+'),psi('+'))*dS                ]

A = block_assemble(a)
L = block_assemble(l)

# print(A.array())

# ---------------------------------------------------------------------
# Compute solution
U = BlockFunction(V) # initialize solution function object
block_solve(A, U.block_vector(), L) # solve linear variational problem

# ---------------------------------------------------------------------
# PLOT SOLUTION
plt.figure()
p = plot(U[0][1])
plt.show()

# # calculate error
# err_pressure = errornorm(pressure_a,U[3],'L2')
# print(err_pressure)

# # equivalent error calculation method (although larger error)
# error = (pressure_a - U[3])**2*dx(2)
# E = sqrt(abs(assemble(error)))
# print(E)

error = (stress_a[0,0]-U[0][0])**2*dx(solid_dom)
E = sqrt(abs(assemble(error)))
print(E)

# ---------------------------------------------------------------------
# # evaluate at eval_points and export
# stress_python = numpy.zeros([numpy.size(eval_points,1), 4])
# pressure_python = numpy.zeros([numpy.size(eval_points,1), 1])
# plotvals = numpy.zeros([numpy.size(eval_points,1), 1])
# # bbt = mesh.bounding_box_tree()
# # x = Point(2.5,0)
# # print(bbt.compute_first_entity_collision(x))

# for i in range(numpy.size(eval_points,1)):
#   x = Point(eval_points[0,i],eval_points[1,i])
#   stress_python[i,:] = numpy.append(U[0](x), U[1](x))
#   pressure_python[i] = U[3](x)
#   plotvals[i] = pressure_python[i] - pressure_a(x)
#   # print(stress_python[i,:])

# N = 10000
# idx=random.sample(range(numpy.size(eval_points,1)),N)

# fig = plt.figure(figsize=(7, 7))
# ax = fig.add_subplot(projection='3d')
# ax.scatter(eval_points[0,idx],eval_points[1,idx],plotvals[idx],marker=".")
# plt.show()

# # export
# # note: need to transpose pressure vec for matlab to read properly
# stress_python = numpy.transpose(stress_python) # i think h5py reads opposite to the way h5(matlab) writes, and vice versa 
# W = h5py.File('./stress_python.h5','w')
# W.create_dataset(name='data', data=stress_python, dtype='f4') # to current directory
# W = h5py.File('./pressure_python.h5','w')
# W.create_dataset(name='data', data=pressure_python, dtype='f4') # to current directory

# W = h5py.File('../Thanh Research/FEM local/src_copy/stress_python.h5','w')
# W.create_dataset(name='data', data=stress_python, dtype='f4') # to matlab directory
# W = h5py.File('../Thanh Research/FEM local/src_copy/pressure_python.h5','w')
# W.create_dataset(name='data', data=pressure_python, dtype='f4') # to matlab directory
